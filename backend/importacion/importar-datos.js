import PocketBase from 'pocketbase';
import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

// Obtener el directorio actual en m√≥dulos ES
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Configuraci√≥n
const pocketbaseConfig = {
  url: 'http://127.0.0.1:8090',
  admin: {
    email: 'yo@mail.com',
    password: 'Ninami12$ya'
  }
};

const CONFIG = {
  directorioTransformados: path.resolve(__dirname, '../../datos_transformados'),
  logFile: path.resolve(__dirname, '../../logs/importacion.log')
};

// Asegurar que el directorio de logs exista
const logDir = path.dirname(CONFIG.logFile);
if (!fs.existsSync(logDir)) {
  fs.mkdirSync(logDir, { recursive: true });
}

// Instancia de PocketBase
const pb = new PocketBase(pocketbaseConfig.url);

// Funci√≥n para escribir en el log
function escribirLog(mensaje) {
  const timestamp = new Date().toISOString();
  const logMensaje = `[${timestamp}] ${mensaje}\n`;
  
  console.log(mensaje);
  
  fs.appendFileSync(CONFIG.logFile, logMensaje, 'utf8');
}

// Funci√≥n para autenticar como superadmin
async function autenticarAdmin() {
  try {
    // Verificar si ya estamos autenticados
    if (pb.authStore.isValid && pb.authStore.model?.id) {
      escribirLog('‚úÖ Ya estamos autenticados como superadmin');
      return;
    }

    // Limpiar cualquier autenticaci√≥n previa
    pb.authStore.clear();

    // Autenticar como superadmin
    const adminEmail = pocketbaseConfig.admin.email;
    const adminPassword = pocketbaseConfig.admin.password;
    
    escribirLog(`üîë Autenticando como superadmin (${adminEmail})...`);
    
    // Intentar directamente con la colecci√≥n de superusuarios
    await pb.collection('_superusers').authWithPassword(adminEmail, adminPassword);
    escribirLog('‚úÖ Autenticaci√≥n exitosa como superusuario');
  } catch (error) {
    escribirLog(`‚ùå Error al autenticar: ${error.message}`);
    throw new Error(`Error de autenticaci√≥n: ${error.message}`);
  }
}

// Funci√≥n para leer datos transformados
function leerDatosTransformados(archivo) {
  try {
    const rutaArchivo = path.join(CONFIG.directorioTransformados, archivo);
    
    if (!fs.existsSync(rutaArchivo)) {
      escribirLog(`‚ùå El archivo ${rutaArchivo} no existe`);
      return [];
    }
    
    escribirLog(`üìÑ Leyendo datos de: ${rutaArchivo}`);
    const contenido = fs.readFileSync(rutaArchivo, 'utf8');
    const datos = JSON.parse(contenido);
    
    escribirLog(`‚úÖ Datos le√≠dos correctamente. ${datos.length} registros encontrados.`);
    return datos;
  } catch (error) {
    escribirLog(`‚ùå Error al leer datos de ${archivo}: ${error.message}`);
    return [];
  }
}

// Funci√≥n para importar categor√≠as
async function importarCategorias(categorias) {
  escribirLog('üîÑ Importando categor√≠as...');
  
  const categoriasMap = new Map();
  let creadas = 0;
  let actualizadas = 0;
  let errores = 0;
  
  for (const categoria of categorias) {
    try {
      // Verificar si la categor√≠a ya existe
      const filtro = `nombre="${categoria.nombre}"`;
      const existentes = await pb.collection('categorias').getFullList({ filter: filtro });
      
      if (existentes.length > 0) {
        // Actualizar categor√≠a existente
        const id = existentes[0].id;
        await pb.collection('categorias').update(id, categoria);
        categoriasMap.set(categoria.nombre.toUpperCase(), id);
        actualizadas++;
        escribirLog(`üîÑ Categor√≠a actualizada: ${categoria.nombre}`);
      } else {
        // Crear nueva categor√≠a
        const nuevaCategoria = await pb.collection('categorias').create(categoria);
        categoriasMap.set(categoria.nombre.toUpperCase(), nuevaCategoria.id);
        creadas++;
        escribirLog(`‚úÖ Categor√≠a creada: ${categoria.nombre}`);
      }
    } catch (error) {
      escribirLog(`‚ùå Error al importar categor√≠a ${categoria.nombre}: ${error.message}`);
      // Intentar crear con campos m√≠nimos si falla
      try {
        const categoriaMinima = {
          nombre: categoria.nombre,
          activo: true
        };
        const nuevaCategoria = await pb.collection('categorias').create(categoriaMinima);
        categoriasMap.set(categoria.nombre.toUpperCase(), nuevaCategoria.id);
        creadas++;
        escribirLog(`‚úÖ Categor√≠a creada con campos m√≠nimos: ${categoria.nombre}`);
      } catch (innerError) {
        escribirLog(`‚ùå Error al crear categor√≠a m√≠nima ${categoria.nombre}: ${innerError.message}`);
        errores++;
      }
    }
  }
  
  escribirLog(`üìä Resumen de importaci√≥n de categor√≠as:`);
  escribirLog(`‚úÖ Creadas: ${creadas}`);
  escribirLog(`üîÑ Actualizadas: ${actualizadas}`);
  escribirLog(`‚ùå Errores: ${errores}`);
  
  return categoriasMap;
}

// Funci√≥n para importar proveedores
async function importarProveedores(proveedores) {
  escribirLog('üîÑ Importando proveedores...');
  
  const proveedoresMap = new Map();
  let creados = 0;
  let actualizados = 0;
  let errores = 0;
  
  for (const proveedor of proveedores) {
    try {
      // Verificar si el proveedor ya existe
      const filtro = `nombre="${proveedor.nombre}"`;
      const existentes = await pb.collection('proveedores').getFullList({ filter: filtro });
      
      if (existentes.length > 0) {
        // Actualizar proveedor existente
        const id = existentes[0].id;
        await pb.collection('proveedores').update(id, proveedor);
        proveedoresMap.set(proveedor.nombre.toUpperCase(), id);
        actualizados++;
        escribirLog(`üîÑ Proveedor actualizado: ${proveedor.nombre}`);
      } else {
        // Crear nuevo proveedor
        const nuevoProveedor = await pb.collection('proveedores').create(proveedor);
        proveedoresMap.set(proveedor.nombre.toUpperCase(), nuevoProveedor.id);
        creados++;
        escribirLog(`‚úÖ Proveedor creado: ${proveedor.nombre}`);
      }
    } catch (error) {
      escribirLog(`‚ùå Error al importar proveedor ${proveedor.nombre}: ${error.message}`);
      // Intentar crear con campos m√≠nimos si falla
      try {
        const proveedorMinimo = {
          nombre: proveedor.nombre,
          activo: true
        };
        const nuevoProveedor = await pb.collection('proveedores').create(proveedorMinimo);
        proveedoresMap.set(proveedor.nombre.toUpperCase(), nuevoProveedor.id);
        creados++;
        escribirLog(`‚úÖ Proveedor creado con campos m√≠nimos: ${proveedor.nombre}`);
      } catch (innerError) {
        escribirLog(`‚ùå Error al crear proveedor m√≠nimo ${proveedor.nombre}: ${innerError.message}`);
        errores++;
      }
    }
  }
  
  escribirLog(`üìä Resumen de importaci√≥n de proveedores:`);
  escribirLog(`‚úÖ Creados: ${creados}`);
  escribirLog(`üîÑ Actualizados: ${actualizados}`);
  escribirLog(`‚ùå Errores: ${errores}`);
  
  return proveedoresMap;
}

// Funci√≥n para importar productos
async function importarProductos(productos, categoriasMap, proveedoresMap) {
  escribirLog('üîÑ Importando productos...');
  
  let creados = 0;
  let actualizados = 0;
  let errores = 0;
  
  for (const producto of productos) {
    try {
      // Preparar datos del producto para PocketBase
      const productoPB = { 
        codigo: producto.codigo,
        nombre: producto.nombre,
        descripcion_larga: producto.descripcion_larga,
        precio_compra: producto.precio_compra || 0,
        precio_venta: producto.precio_venta || 0,
        iva: producto.iva || 21,
        stock_actual: producto.stock_actual || 0,
        stock_minimo: producto.stock_minimo || 1,
        activo: true,
        fecha_alta: producto.fecha_alta || new Date().toISOString()
      };
      
      // Asignar ID de categor√≠a si existe
      if (producto.categoria && categoriasMap.has(producto.categoria.toUpperCase())) {
        productoPB.categoria = categoriasMap.get(producto.categoria.toUpperCase());
      }
      
      // Asignar ID de proveedor si existe
      if (producto.proveedor && proveedoresMap.has(producto.proveedor.toUpperCase())) {
        productoPB.proveedor = proveedoresMap.get(producto.proveedor.toUpperCase());
      }
      
      // Verificar si el producto ya existe
      const filtro = `codigo="${producto.codigo}"`;
      const existentes = await pb.collection('productos').getFullList({ filter: filtro });
      
      if (existentes.length > 0) {
        // Actualizar producto existente
        const id = existentes[0].id;
        await pb.collection('productos').update(id, productoPB);
        actualizados++;
        
        if (actualizados % 10 === 0) {
          escribirLog(`üîÑ ${actualizados} productos actualizados...`);
        }
      } else {
        // Crear nuevo producto
        await pb.collection('productos').create(productoPB);
        creados++;
        
        if (creados % 10 === 0) {
          escribirLog(`‚úÖ ${creados} productos creados...`);
        }
      }
    } catch (error) {
      escribirLog(`‚ùå Error al importar producto ${producto.codigo}: ${error.message}`);
      // Intentar crear con campos m√≠nimos si falla
      try {
        const productoMinimo = {
          codigo: producto.codigo,
          nombre: producto.nombre || `Producto ${producto.codigo}`,
          activo: true
        };
        await pb.collection('productos').create(productoMinimo);
        creados++;
        escribirLog(`‚úÖ Producto creado con campos m√≠nimos: ${producto.codigo}`);
      } catch (innerError) {
        escribirLog(`‚ùå Error al crear producto m√≠nimo ${producto.codigo}: ${innerError.message}`);
        errores++;
      }
    }
  }
  
  escribirLog(`üìä Resumen de importaci√≥n de productos:`);
  escribirLog(`‚úÖ Creados: ${creados}`);
  escribirLog(`üîÑ Actualizados: ${actualizados}`);
  escribirLog(`‚ùå Errores: ${errores}`);
}

// Funci√≥n para registrar la importaci√≥n
async function registrarImportacion(resumen) {
  try {
    const importacion = {
      fecha: new Date().toISOString(),
      archivo: 'datos_transformados',
      estado: 'completado',
      registros_procesados: resumen.total,
      registros_creados: resumen.creados,
      registros_actualizados: resumen.actualizados,
      registros_con_error: resumen.errores,
      log: `Importaci√≥n completada. ${resumen.creados} creados, ${resumen.actualizados} actualizados, ${resumen.errores} errores.`
    };
    
    const nuevaImportacion = await pb.collection('importaciones').create(importacion);
    escribirLog(`‚úÖ Importaci√≥n registrada con ID: ${nuevaImportacion.id}`);
    
    return nuevaImportacion.id;
  } catch (error) {
    escribirLog(`‚ùå Error al registrar la importaci√≥n: ${error.message}`);
    return null;
  }
}

// Funci√≥n principal
async function main() {
  try {
    escribirLog('üöÄ Iniciando proceso de importaci√≥n de datos...');
    
    // Autenticar como superadmin
    await autenticarAdmin();
    
    // Leer datos transformados
    const categorias = leerDatosTransformados('categorias.json');
    const proveedores = leerDatosTransformados('proveedores.json');
    const productos = leerDatosTransformados('productos.json');
    
    // Importar datos
    const categoriasMap = await importarCategorias(categorias);
    const proveedoresMap = await importarProveedores(proveedores);
    await importarProductos(productos, categoriasMap, proveedoresMap);
    
    // Registrar importaci√≥n
    const resumen = {
      total: categorias.length + proveedores.length + productos.length,
      creados: 0, // Esto deber√≠a actualizarse con los valores reales
      actualizados: 0, // Esto deber√≠a actualizarse con los valores reales
      errores: 0 // Esto deber√≠a actualizarse con los valores reales
    };
    
    await registrarImportacion(resumen);
    
    escribirLog('üèÅ Proceso de importaci√≥n finalizado');
    
  } catch (error) {
    escribirLog(`‚ùå Error en el proceso de importaci√≥n: ${error.message}`);
  }
}

// Ejecutar funci√≥n principal
main().catch(error => {
  escribirLog(`‚ùå Error fatal: ${error.message}`);
  process.exit(1);
});
