/**
 * Sistema de importación para El Pelotazo
 * Este módulo maneja la importación de datos desde diferentes formatos y proveedores
 * Versión refactorizada y optimizada
 */

import { pocketbaseConfig } from './config.js';
import { autenticarAdmin, fetchAdmin } from './utils.js';
import path from 'path';

// Importar módulos refactorizados
import { leerArchivoCSV, leerArchivoExcel, leerArchivoJSONNormalizado } from './file-readers.js';
import { 
  parserGenericoUniversal, 
  parseCecotec, 
  parseBSH, 
  parseJata, 
  parseOrbegozo, 
  parseAlfadyser, 
  parseVitrokitchen, 
  parseElectrodirecto, 
  parseAlmacenes,
  parseEasJohnson, // Agregar el parser para EAS-JOHNSON
  proveedorParsers, // Importar el mapa de proveedores a parsers
  proveedoresNormalizados // Importar el mapa de nombres normalizados de proveedores
} from './parsers.js';
import { detectarCategorias, asignarCategoria, analizarNota } from './categorias.js';
import { obtenerIdCategoria, importarProducto, actualizarProducto, actualizarLog, registrarDevolucion } from './db-utils.js';
import { generarIdProveedor } from './generarIdProveedor.js';

// URL base de PocketBase
const baseUrl = pocketbaseConfig.url;

// --- LOG DETALLADO ANTES DE CADA ENVÍO DE PRODUCTO ---
function logProductoEnvio(accion, body) {
  console.log(`\n[${accion}] Enviando producto a PocketBase:`);
  try {
    console.log(JSON.stringify(body, null, 2));
  } catch(e) {
    console.log(body);
  }
}

/**
 * Importar datos desde un archivo a la base de datos
 * @param {string} filePath - Ruta del archivo a importar
 * @param {string} proveedor - Nombre del proveedor
 * @param {string} tipo - Tipo de importación (productos, precios, stock)
 * @param {string} importacionId - ID de la importación
 * @returns {Promise<Object>} - Resultado de la importación
 */
export async function importarDatos(filePath, proveedor, tipo = 'productos', importacionId = null) {
  console.log(`Iniciando importación desde ${filePath} para proveedor ${proveedor}`);
  
  try {
    // Determinar el tipo de archivo basado en la extensión
    const fileType = path.extname(filePath).slice(1).toLowerCase();
    console.log(`Tipo de archivo detectado: ${fileType}`);
    
    // Leer archivo según su tipo
    let datos;
    if (fileType === 'csv') {
      datos = await leerArchivoCSV(filePath);
    } else if (fileType === 'xlsx' || fileType === 'xls') {
      datos = await leerArchivoExcel(filePath);
    } else if (fileType === 'json') {
      datos = await leerArchivoJSONNormalizado(filePath);
    } else {
      console.error(`Tipo de archivo no soportado: ${fileType}`);
      return {
        exito: false,
        error: `Tipo de archivo no soportado: ${fileType}`
      };
    }
    console.log(`Leídos ${datos.length} registros del archivo`);
    
    // Actualizar log si hay ID de importación
    if (importacionId) {
      await actualizarLog(importacionId, `Leídos ${datos.length} registros del archivo`);
    }
    
    // Procesar datos según el proveedor
    const resultado = await procesarArchivo(datos, proveedor);
    console.log(`Procesados ${resultado.productos.length} registros`);
    
    // Actualizar log si hay ID de importación
    if (importacionId) {
      await actualizarLog(importacionId, `Procesados ${resultado.productos.length} registros`);
    }
    
    // Detectar categorías explícitamente después de procesar los datos
    const categoriasDetectadas = await detectarCategorias(resultado.productos || []);
    const categoriasUnicasMap = {};
    for (const cat of categoriasDetectadas) {
      const catId = await obtenerIdCategoria(cat.nombre, fetchAdmin); // Usar obtenerIdCategoria para obtener o crear ID
      if (catId) {
        categoriasUnicasMap[cat.nombre] = catId;
      }
    }
    console.log(`Detectadas y mapeadas ${Object.keys(categoriasUnicasMap).length} categorías`);
    
    // Actualizar log si hay ID de importación
    if (importacionId) {
      await actualizarLog(importacionId, `Detectadas y mapeadas ${Object.keys(categoriasUnicasMap).length} categorías`);
    }
    
    // Importar a la base de datos
    const resultadoImportacion = await importarABaseDeDatos(
      resultado.productos, 
      proveedor, 
      importacionId, 
      fetchAdmin, 
      categoriasUnicasMap
    );
    
    console.log(`Importación completada: ${resultadoImportacion.stats.creados} creados, ${resultadoImportacion.stats.actualizados} actualizados, ${resultadoImportacion.stats.errores} errores`);
    
    // Actualizar log si hay ID de importación
    if (importacionId) {
      await actualizarLog(importacionId, `Importación completada: ${resultadoImportacion.stats.creados} creados, ${resultadoImportacion.stats.actualizados} actualizados, ${resultadoImportacion.stats.errores} errores`);
    }
    
    return resultadoImportacion;
  } catch (error) {
    console.error('Error en importación:', error);
    
    // Actualizar log si hay ID de importación
    if (importacionId) {
      await actualizarLog(importacionId, `Error en importación: ${error.message}`);
    }
    
    return {
      exito: false,
      error: error.message || 'Error desconocido en la importación'
    };
  }
}

/**
 * Procesar archivo según el proveedor
 * @param {Array} datos - Datos a procesar
 * @param {string} proveedor - Nombre del proveedor
 * @returns {Object} - Datos procesados
 */
async function procesarArchivo(datos, proveedor) {
  // Normalizar nombre del proveedor
  const proveedorOriginal = (proveedor || '').trim();
  const proveedorNormalizado = proveedorOriginal.toUpperCase();
  
  console.log(`[procesarArchivo] Procesando datos para proveedor: ${proveedorOriginal} (normalizado: ${proveedorNormalizado})`);
  
  // Intentar detectar el proveedor desde los datos si no se especificó
  let proveedorDetectado = proveedorNormalizado;
  
  if (!proveedorDetectado || proveedorDetectado === 'GENERICO' || proveedorDetectado === '') {
    console.log(`[procesarArchivo] Intentando detectar proveedor desde los datos...`);
    
    // Buscar en la primera fila para ver si hay alguna clave que indique el proveedor
    if (datos && datos.length > 0) {
      const primeraFila = datos[0];
      for (const key in primeraFila) {
        if (key && typeof key === 'string') {
          // Verificar si la clave es un nombre de proveedor conocido
          const keyUpper = key.toUpperCase();
          if (proveedoresNormalizados[keyUpper]) {
            proveedorDetectado = keyUpper;
            console.log(`[procesarArchivo] Proveedor detectado automáticamente de la clave: ${proveedorDetectado}`);
            break;
          }
          
          // Verificar si el valor es un nombre de proveedor conocido
          if (primeraFila[key] && typeof primeraFila[key] === 'string') {
            const valueUpper = primeraFila[key].toString().toUpperCase();
            if (proveedoresNormalizados[valueUpper]) {
              proveedorDetectado = valueUpper;
              console.log(`[procesarArchivo] Proveedor detectado automáticamente del valor: ${proveedorDetectado}`);
              break;
            }
          }
        }
      }
    }
  }
  
  // Usar el nombre normalizado del proveedor si existe en el mapa
  const proveedorFinal = proveedoresNormalizados[proveedorDetectado] || proveedorDetectado;
  
  console.log(`[procesarArchivo] Proveedor final: ${proveedorFinal}`);
  
  // Seleccionar parser según el proveedor usando el mapa de proveedores a parsers
  let resultado;
  
  // Verificar si existe un parser específico para el proveedor
  if (proveedorParsers[proveedorFinal]) {
    console.log(`[procesarArchivo] Usando parser específico para ${proveedorFinal}`);
    resultado = proveedorParsers[proveedorFinal](datos, 'productos');
  } else {
    // Intentar encontrar un parser por coincidencia parcial
    let parserEncontrado = false;
    for (const [clave, parser] of Object.entries(proveedorParsers)) {
      if (proveedorFinal.includes(clave) || clave.includes(proveedorFinal)) {
        console.log(`[procesarArchivo] Usando parser para ${clave} por coincidencia parcial con ${proveedorFinal}`);
        resultado = parser(datos, 'productos');
        parserEncontrado = true;
        break;
      }
    }
    
    if (!parserEncontrado) {
      // Casos especiales para nombres compuestos
      if (proveedorFinal.includes('EAS') || proveedorFinal.includes('JOHNSON')) {
        console.log('[procesarArchivo] Usando parser específico para EAS-JOHNSON');
        resultado = parseEasJohnson(datos, 'productos');
      } else if (proveedorFinal.includes('CECOTEC')) {
        console.log('[procesarArchivo] Usando parser específico para CECOTEC');
        resultado = parseCecotec(datos, 'productos');
      } else if (proveedorFinal.includes('ALFADYSER')) {
        console.log('[procesarArchivo] Usando parser específico para ALFADYSER');
        resultado = parseAlfadyser(datos, 'productos');
      } else {
        // Parser genérico para cualquier otro proveedor
        console.log(`[procesarArchivo] No se encontró parser específico para el proveedor "${proveedorFinal}", usando parser genérico universal`);
        resultado = parserGenericoUniversal(datos, 'productos', { proveedor: proveedorFinal });
      }
    }
  }
  
  // Asegurarse de que el resultado tenga la estructura esperada
  if (!resultado || !resultado.productos) {
    console.error(`[procesarArchivo] El parser para ${proveedorFinal} no devolvió productos válidos`);
    return { productos: [] };
  }
  
  // Asegurarse de que todos los productos tengan el proveedor correcto
  resultado.productos = resultado.productos.map(producto => ({
    ...producto,
    proveedor_nombre: proveedorFinal
  }));
  
  console.log(`[procesarArchivo] Procesados ${resultado.productos.length} productos para ${proveedorFinal}`);
  
  return resultado;
}

/**
 * Importar datos procesados a la base de datos
 * @param {Array} datos - Datos procesados a importar
 * @param {string} proveedorNombre - Nombre del proveedor
 * @param {string} importacionId - Identificador único de la importación
 * @param {Function} fetchAdminFunc - Función para hacer peticiones autenticadas a PocketBase
 * @param {Object} categoriasMap - Mapa de categorías detectadas y sus IDs
 * @returns {Promise<Object>} - Resultado de la importación
 */
async function importarABaseDeDatos(datos, proveedorNombre, importacionId, fetchAdminFunc, categoriasMap) {
  console.log(`Importando ${datos.length} productos a la base de datos para proveedor ${proveedorNombre || 'desconocido'}`);
  
  if (!fetchAdminFunc) { // Verificación del parámetro renombrado
    console.error('Error Crítico: fetchAdminFunc no proporcionado a importarABaseDeDatos.');
    return {
      exito: false,
      error: 'Función fetchAdmin no configurada para la importación.',
      stats: { total: datos.length, creados: 0, actualizados: 0, errores: datos.length, erroresDetalle: [{ producto: 'General', error: 'fetchAdmin no configurado' }], devoluciones: 0 }
    };
  }

  // Variables para estadísticas
  const stats = {
    total: datos.length,
    creados: 0,
    actualizados: 0,
    errores: 0,
    erroresDetalle: [],
    devoluciones: 0
  };
  
  try {
    // 1. Generar ID del PROVEEDOR PRINCIPAL directamente
    let idProveedorPrincipal = null;
    if (proveedorNombre) {
      console.log(`[importarABaseDeDatos] Generando ID para el proveedor principal: ${proveedorNombre}`);
      
      // Generar directamente un ID para el proveedor principal
      idProveedorPrincipal = generarIdProveedor(proveedorNombre);
      console.log(`[importarABaseDeDatos] ID del proveedor principal generado: ${idProveedorPrincipal}`);
    }
    
    // Si no tenemos proveedor principal, generar uno genérico
    if (!idProveedorPrincipal) {
      idProveedorPrincipal = generarIdProveedor('GENERICO');
      console.warn(`[importarABaseDeDatos] Usando ID generado para proveedor genérico: ${idProveedorPrincipal}`);
    }
    
    // Pre-crear o obtener IDs de categorías usando obtenerIdCategoria
    const categoriasFinales = {};
    for (const catNombre of Object.keys(categoriasMap)) {
      const catId = await obtenerIdCategoria(catNombre, fetchAdminFunc);
      if (catId) {
        categoriasFinales[catNombre] = catId;
      }
    }
    console.log(`Categorías finales mapeadas: ${JSON.stringify(categoriasFinales)}`);
    
    // 2. Procesar cada producto
    for (const producto of datos) {
      try {
        // Obtener el proveedor específico del producto (si es diferente del principal)
        let idProveedor = idProveedorPrincipal;
        if (producto.proveedor_nombre) {
          // Normalizar el nombre del proveedor para comparación
          const nombreProveedorNormalizado = producto.proveedor_nombre.trim().toUpperCase();
          const nombrePrincipalNormalizado = proveedorNombre ? proveedorNombre.trim().toUpperCase() : '';
          
          // Solo procesar si es diferente del principal (comparación normalizada)
          if (nombreProveedorNormalizado && 
              (!nombrePrincipalNormalizado || nombreProveedorNormalizado !== nombrePrincipalNormalizado)) {
            
            console.log(`[importarABaseDeDatos] Producto con proveedor específico: ${producto.proveedor_nombre} (diferente de ${proveedorNombre || 'ninguno'})`);
            
            // Generar directamente un ID para el proveedor específico sin intentar crearlo en PocketBase
            console.log(`[importarABaseDeDatos] Generando ID para proveedor específico: ${producto.proveedor_nombre}`);
            
            // Usar la función de generación de IDs
            const idProveedorEspecifico = generarIdProveedor(producto.proveedor_nombre);
            
            idProveedor = idProveedorEspecifico;
            console.log(`[importarABaseDeDatos] ID del proveedor específico generado: ${idProveedor}`);
            }
            
            // Si después de todos los intentos no se encontró el proveedor, usar el principal
            if (!proveedorEncontrado) {
              console.warn(`[importarABaseDeDatos] No se pudo obtener/crear el proveedor específico ${producto.proveedor_nombre} después de ${maxIntentosProveedor} intentos, usando proveedor principal`);
              idProveedor = idProveedorPrincipal;
            }
          } else {
            console.log(`[importarABaseDeDatos] Proveedor específico ${producto.proveedor_nombre} es igual al principal ${proveedorNombre}, usando el principal`);
          }
        }
        
        // Validar que el item tenga datos válidos
        if (!producto || typeof producto !== 'object') {
          console.log(`Ítem no válido, saltando...`);
          continue;
        }
        
        // Utilidad para normalizar precios y asegurar que nunca falte precio_venta
        function normalizaPrecio(valor, fallback = 0) {
          if (valor === undefined || valor === null) return fallback;
          if (typeof valor === 'number') return valor;
          if (typeof valor === 'string') {
            const limpio = valor.replace(/[^\d.,]/g, '').replace(',', '.');
            const num = parseFloat(limpio);
            if (!isNaN(num)) return num;
          }
          return fallback;
        }

        // Añadir log para ver el item completo que viene del parser
        console.log(`[importarABaseDeDatos] Procesando item:`, JSON.stringify(producto));

        // Validar precio_venta antes de construir el producto
        // Ahora esperamos que item.precio_venta venga directamente del parser
        let precioVentaValido = normalizaPrecio(producto.precio_venta, 0);
        // Permitir precio 0 si explícitamente es 0 o "0", pero no si es undefined, null, o texto no numérico
        if (precioVentaValido <= 0 && producto.precio_venta !== 0 && String(producto.precio_venta).trim() !== '0') {
          stats.errores++;
          // El log de error usará el valor de item.precio_venta tal como llegó
          stats.erroresDetalle.push({ 
            producto: producto.codigo || `Item`, 
            error: `Precio de venta inválido o cero. Valor recibido del parser: '${producto.precio_venta}'` 
          });
          continue; // Saltar este producto
        }

        // Crear el objeto base del producto
        const productoBase = {
          codigo: String(producto.codigo || producto.CODIGO || producto.EAN || producto.REFERENCIA || `SIN_CODIGO`),
          nombre: String(producto.nombre || producto.DESCRIPCION || producto.CONCEPTO || producto.TITULO || 'Sin Nombre'),
          descripcion: String(producto.descripcion_larga || producto.DESCRIPCION || ''), // Usar un campo más descriptivo si existe
          
          // Campos financieros - preservar valores originales sin recalcular
          precio_compra: normalizaPrecio(producto.precio_compra || producto.PRECIO_COMPRA || producto.NETO || 0, 0),
          precio_venta: precioVentaValido,
          iva: normalizaPrecio(producto.iva || producto.iva_recargo || producto.IVA || 21, 21),
          
          // Campos de inventario (ajustados a PocketBase)
          stock_actual: parseInt(producto.stock_actual || producto.stock || producto.STOCK || producto.UNIDADES || producto['UNID.'] || producto['QUEDAN EN TIENDA'] || 0, 10),
          unidades_vendidas: parseInt(producto.unidades_vendidas || producto.vendidas || producto['VENDIDAS'] || 0, 10),
          
          // Campos adicionales específicos
          margen: normalizaPrecio(producto.margen || 0),
          descuento: normalizaPrecio(producto.descuento || producto.descuento1 || 0),
          descuento_adicional: normalizaPrecio(producto.descuento2 || 0),
          beneficio_unitario: normalizaPrecio(producto.beneficio_unitario || 0),
          beneficio_total: normalizaPrecio(producto.beneficio_total || 0),
          vendidas: parseInt(producto.vendidas || 0, 10),
          pvp_web: normalizaPrecio(producto.pvp_web || 0),
          
          // Estado del producto
          activo: true,
          visible: true, // Asegurarnos de que el producto sea visible
          
          // Datos completos para referencia
          datos_origen: JSON.stringify(producto) // Guardar datos originales para referencia
        };
        
        // Log detallado del producto base que se va a procesar
        console.log(`[DEBUG] Producto base mapeado para PB:`, JSON.stringify(productoBase, null, 2));
        if (!productoBase.codigo || productoBase.codigo.startsWith('SIN_CODIGO_')) {
          console.log(`Producto sin código válido, saltando...`);
          continue;
        }
        
        console.log(`Procesando producto: ${productoBase.codigo} - ${productoBase.nombre}`);
        
        // ASIGNACIÓN DE CATEGORÍA
        if (producto.categoriaExtraidaDelParser) {
          const categoriaNombre = producto.categoriaExtraidaDelParser.trim();
          const categoriaId = await obtenerIdCategoria(categoriaNombre, fetchAdminFunc);
          if (categoriaId) {
            productoBase.categoria = categoriaId;
            console.log(`Categoría ID ${categoriaId} asignada a producto ${productoBase.codigo}`);
          } else {
            console.warn(`No se pudo resolver o crear categoría '${categoriaNombre}' para el producto ${productoBase.codigo}.`);
            stats.erroresDetalle.push({ producto: productoBase.codigo, campo: 'categoria', valor: categoriaNombre, error: `ID no resuelto después de intento de creación.` });
          }
        } else {
          console.log(`No se detectó categoría en el parser para el producto ${productoBase.codigo}.`);
        }

        // ASIGNAR PROVEEDOR
        // Primero intentamos usar el proveedor específico del producto (si existe)
        if (idProveedor) {
          productoBase.proveedor = idProveedor;
          console.log(`[importarABaseDeDatos] Asignado proveedor con ID: ${idProveedor} al producto ${productoBase.codigo}`);
        } 
        // Si no hay proveedor específico, intentamos usar el proveedor principal
        else if (idProveedorPrincipal) {
          productoBase.proveedor = idProveedorPrincipal;
          console.log(`[importarABaseDeDatos] Asignado proveedor principal con ID: ${idProveedorPrincipal} al producto ${productoBase.codigo}`);
        } 
        // Si no hay ningún proveedor disponible, intentamos crear uno basado en el nombre del proveedor del producto
        else {
          // Intentar crear un proveedor basado en el nombre del proveedor del producto
          const nombreProveedorProducto = producto.proveedor_nombre || proveedorNombre;
          if (nombreProveedorProducto) {
            try {
              console.log(`[importarABaseDeDatos] Intentando crear proveedor para el producto: ${nombreProveedorProducto}`);
              const nuevoIdProveedor = await obtenerIdProveedor(nombreProveedorProducto, fetchAdminFunc);
              if (nuevoIdProveedor) {
                productoBase.proveedor = nuevoIdProveedor;
                console.log(`[importarABaseDeDatos] Creado y asignado nuevo proveedor con ID: ${nuevoIdProveedor} al producto ${productoBase.codigo}`);
              } else {
                console.warn(`[importarABaseDeDatos] No se pudo crear proveedor para el producto ${productoBase.codigo}`);
                stats.erroresDetalle.push({ producto: productoBase.codigo, campo: 'proveedor', valor: nombreProveedorProducto, error: `No se pudo crear proveedor.` });
              }
            } catch (error) {
              console.error(`[importarABaseDeDatos] Error al crear proveedor para el producto ${productoBase.codigo}:`, error);
              stats.erroresDetalle.push({ producto: productoBase.codigo, campo: 'proveedor', valor: nombreProveedorProducto, error: `Error al crear proveedor: ${error.message}` });
            }
          } else {
            console.warn(`[importarABaseDeDatos] No hay nombre de proveedor disponible para el producto ${productoBase.codigo}`);
            stats.erroresDetalle.push({ producto: productoBase.codigo, campo: 'proveedor', error: `No hay nombre de proveedor disponible.` });
          }
        }
        
        // Verificar si el producto existe antes de actualizar o crear
        const filtroProducto = encodeURIComponent(`codigo = "${productoBase.codigo}"`);
        const urlBusquedaProducto = `/api/collections/productos/records?filter=${filtroProducto}`;
        const existentes = await fetchAdminFunc(urlBusquedaProducto);
        if (existentes.items && existentes.items.length > 0) {
          // Producto existe, actualizarlo
          const productoExistente = existentes.items[0];
          console.log(`[importarABaseDeDatos] Producto existente encontrado con ID: ${productoExistente.id}`);
          
          // Preservar relaciones existentes si no tenemos nuevas
          const productoActualizado = { ...productoBase };
          
          // Mantener la categoría existente si no tenemos una nueva
          if (!productoActualizado.categoria && productoExistente.categoria) {
            productoActualizado.categoria = productoExistente.categoria;
            console.log(`[importarABaseDeDatos] Manteniendo categoría existente: ${productoExistente.categoria}`);
          }
          
          // Mantener el proveedor existente si no tenemos uno nuevo
          if (!productoActualizado.proveedor && productoExistente.proveedor) {
            productoActualizado.proveedor = productoExistente.proveedor;
            console.log(`[importarABaseDeDatos] Manteniendo proveedor existente: ${productoExistente.proveedor}`);
          }
          
          // Actualizar el producto
          try {
            await actualizarProducto(productoExistente.id, productoActualizado, fetchAdminFunc);
            console.log(`[importarABaseDeDatos] Producto actualizado con éxito: ${productoBase.codigo}`);
            stats.actualizados++;
          } catch (error) {
            console.error(`[importarABaseDeDatos] Error al actualizar producto ${productoBase.codigo}:`, error);
            stats.errores++;
            stats.erroresDetalle.push({ producto: productoBase.codigo, error: `Error al actualizar: ${error.message}` });
          }
        } else {
          // Producto no existe, crearlo
          try {
            const nuevoProducto = await importarProducto(productoBase, fetchAdminFunc);
            console.log(`[importarABaseDeDatos] Producto creado con éxito: ${productoBase.codigo}, ID: ${nuevoProducto?.id || 'N/A'}`);
            stats.creados++;
          } catch (error) {
            console.error(`[importarABaseDeDatos] Error al crear producto ${productoBase.codigo}:`, error);
            stats.errores++;
            stats.erroresDetalle.push({ producto: productoBase.codigo, error: `Error al crear: ${error.message}` });
          }
        }
        
        // Verificar si hay notas que indiquen devoluciones
        if (producto.NOTAS || producto.OBSERVACIONES || producto.COMENTARIOS) {
          const analisisNota = analizarNota(producto.NOTAS || producto.OBSERVACIONES || producto.COMENTARIOS);
          if (analisisNota) {
            await registrarDevolucion(productoBase, analisisNota, proveedorNombre, importacionId);
            stats.devoluciones++;
          }
        }
      } catch (error) {
        console.error(`Error al procesar producto ${producto.codigo}:`, error);
        stats.errores++;
      }
    }
    
    stats.exito = stats.errores === 0;
    return {
      exito: stats.exito,
      stats
    };
  } catch (error) {
    console.error(`Error general en la importación: ${error.message}`);
    return {
      exito: false,
      error: error.message,
      stats
    };
  }
  
  console.log(`Importación finalizada. Estadísticas: ${JSON.stringify(stats)}`);
  return {
    exito: true,
    stats
  };
}

// Exportar funciones principales
export default {
  importarDatos
};
